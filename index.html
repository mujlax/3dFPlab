<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Potree-Core Example</title>
  </head>
  <style>
    .class_pizdaslona {
      position: absolute;
      top: 50%;
      left: 50%;
      font-size: 10px;
      color: #58f;
      z-index: 101;
      text-align: center;
      /* width: 50px;
			height: 50px;
			-webkit-border-radius: 25px;
			-moz-border-radius: 25px;
			border-radius: 25px;
			background: red; */
    }

    #menuPanel {
      position: absolute;
      z-index: 100;
      background-color: rgba(255, 255, 255, 0.5);
      top: 0px;
      left: 0px;
      width: 100%;
      height: 100%;
    }

    #startButton {
      height: 50px;
      width: 200px;
      margin: -25px -100px;
      position: absolute;
      top: 50%;
      left: 50%;
      font-size: 32px;
    }
    .slider {
      height: 50px;
      width: 200px;
      position: absolute;
      top: 0%;
      left: 0%;
      font-size: 32px;
    }
  </style>

  <body style="background-color: #000000">
    <script src="lib/threejs/three.min.js"></script>

    <script src="lib/threejs/OrbitControls.js"></script>
    <script src="lib/threejs/FirstPersonControls.js"></script>
    <script src="lib/threejs/FlyControls.js"></script>
    <script src="lib/threejs/PointerLockControls.js"></script>
    <script src="lib/threejs/THREEx.KeyboardState.js"></script>

    <div id="menuPanel">
      <button id="startButton">Click to Start</button>
      <input
        id="range_slider"
        class="slider"
        value="0.20"
        min="0.20"
        max="100"
        onchange="zalupa((this.value/100).toFixed(2))"
        type="range"
        style="margin-top: 50px"
      />
      <div id="value_slider" class="slider"></div>
    </div>
    <div class="class_pizdaslona">&#x25CF;</div>

    <script src="build/potree.min.js"></script>
    <script>
      var distance = 0.2;
      var distance = document.getElementById("range_slider").value;
      let value_slider = document.getElementById("value_slider");
      let speed = "Скорость: ";
      value_slider.innerHTML = speed + distance;

      function zalupa(slideAmount) {
        distance = slideAmount;
        value_slider.innerHTML = speed + slideAmount;
      }

      document.body.onload = function () {
        //three.js
        var keyboard = new THREEx.KeyboardState();
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(90, 1, 0.1, 1000);
        var clock = new THREE.Clock();
        //var keyboard = new THREEx.KeyboardState();

        var canvas = document.createElement("canvas");
        canvas.style.position = "absolute";
        canvas.style.top = "0px";
        canvas.style.left = "0px";
        canvas.style.width = "100%";
        canvas.style.height = "100%";
        document.body.appendChild(canvas);
        // var pizdaslona = document.createElement("div")
        // pizdaslona.className = "class_pizdaslona"
        // pizdaslona.textContent = "&#x25CB;"
        // document.body.appendChild(pizdaslona)
        var renderer = new THREE.WebGLRenderer({
          canvas: canvas,
          alpha: true,
          logarithmicDepthBuffer: true,
          context: null,
          precision: "highp",
          premultipliedAlpha: true,
          antialias: true,
          preserveDrawingBuffer: false,
          powerPreference: "high-performance",
        });

        var geometry = new THREE.BoxBufferGeometry(2500, 1, 2500);
        var material = new THREE.MeshBasicMaterial({ color: 0x44aa44 });
        var cube = new THREE.Mesh(geometry, material);
        cube.position.y = -2;
        //scene.add(cube);

        scene.add(new THREE.AmbientLight(0xffffff));

        // var controls = new THREE.OrbitControls(camera, canvas);
        // camera.position.z = 30;
        // const controls = new THREE.FirstPersonControls(camera, canvas)
        // controls.enabled = true;
        //var controls = new THREE.FlyControls(camera, canvas);

        var controls = new THREE.PointerLockControls(camera, canvas);

        controls.addEventListener(
          "lock",
          () => (menuPanel.style.display = "none")
        );
        controls.addEventListener(
          "unlock",
          () => (menuPanel.style.display = "block")
        );

        //camera.position.z = 30;
        camera.position.y = 15;

        var raycaster = new THREE.Raycaster();
        raycaster.params.Points.threshold = 1e-2;
        var normalized = new THREE.Vector2();

        canvas.onmousemove = function (event) {
          normalized.set(
            (event.clientX / canvas.width) * 2 - 1,
            -(event.clientY / canvas.height) * 2 + 1
          );
          raycaster.setFromCamera(normalized, camera);
        };

        canvas.ondblclick = function (event) {
          var intesects = raycaster.intersectObject(scene, true);

          if (intesects.length > 0) {
            var geometry = new THREE.SphereBufferGeometry(0.1, 32, 32);
            var material = new THREE.MeshBasicMaterial({ color: 0xaa4444 });
            var sphere = new THREE.Mesh(geometry, material);
            sphere.position.copy(intesects[0].point);
            scene.add(sphere);
          }
        };

        Potree.Global.workerPath = "./source";

        // loadPointCloud("data/lion_takanawa_ept_laz/ept.json", new THREE.Vector3(-4, -4, 3.0));
        // loadPointCloud("data/lion_takanawa_ept_bin/ept.json", new THREE.Vector3(-11, -4, 3.0));
        // loadPointCloud("data/test2/cloud.js", new THREE.Vector3(0, 0, 0.0));
        loadPointCloud(
          "data/lion_takanawa/cloud.js",
          new THREE.Vector3(50, 0, 0.0)
        );

        // loadPointCloud("data/lion_takanawa_las/cloud.js", new THREE.Vector3(3, -3, 0.0));
        // loadPointCloud("data/lion_takanawa_laz/cloud.js", new THREE.Vector3(8, -3, 0.0));
        //loadPointCloud("http://arena4d.uksouth.cloudapp.azure.com:8080/4e5059c4-f701-4a8f-8830-59e78a2c0816/BLK360 Sample.vpc");
        //"http://5.9.65.151/mschuetz/potree/resources/pointclouds/faro/skatepark/cloud.js"
        //"http://5.9.65.151/mschuetz/potree/resources/pointclouds/weiss/subseamanifold2/cloud.js"

        const menuPanel = document.getElementById("menuPanel");
        const startButton = document.getElementById("startButton");
        startButton.addEventListener(
          "click",
          function () {
            controls.lock();
            //controls.isLocked = true
          },
          false
        );

        // const onKeyDown = function (event) {
        // 	let distance = 0.25;
        // 	console.log("Letter: ", event.code)
        // 	let keyPressed;
        // 	switch (event.code) {
        // 		case 'KeyW':
        // 			controls.moveForward(distance)
        // 			break
        // 		case 'KeyA':
        // 			controls.moveRight(-0.25)
        // 			break
        // 		case 'KeyS':
        // 			controls.moveForward(-0.25)
        // 			break
        // 		case 'KeyD':
        // 			controls.moveRight(0.25)
        // 			break
        // 	}
        // }
        // document.addEventListener('keydown', onKeyDown, false)
        // document.addEventListener('keyup', onKeyDown, false)

        function loadPointCloud(url, position) {
          Potree.loadPointCloud(url, "pointcloud", function (e) {
            var points = new Potree.Group();
            points.material.opacity = 1.0;
            points.material.wireframe = true;
            scene.add(points);

            var pointcloud = e.pointcloud;

            if (position !== undefined) {
              pointcloud.position.copy(position);
            }

            var material = pointcloud.material;
            material.size = 2;
            material.pointColorType = Potree.PointColorType.RGB; //RGB | DEPTH | HEIGHT | POINT_INDEX | LOD | CLASSIFICATION
            material.pointSizeType = Potree.PointSizeType.ADAPTIVE; //ADAPTIVE | FIXED
            material.shape = Potree.PointShape.CIRCLE; //CIRCLE | SQUARE

            points.add(pointcloud);
          });
        }
        let press = false;
        let delay = 200;
        function move() {
          console.log("SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS");
          // camera.position.y = 15 + px
        }

        let array = [
          "a",
          "b",
          "c",
          "d",
          "e",
          "a",
          "b",
          "c",
          "d",
          "e",
          "a",
          "b",
          "c",
          "d",
          "e",
          "a",
          "b",
          "c",
          "d",
          "e",
          "a",
          "b",
          "c",
          "d",
          "e",
          "a",
          "b",
          "c",
          "d",
          "e",
        ];

        // async function doSetTimout(i){
        // 	await new Promise(() => setTimeout(function() {
        // 		console.log(array[i]);
        // 		camera.position.y = 15 + i
        // 	}, delay*i));
        // 	// return new Promise(resolve => setTimeout(resolve, ms))
        // }
        // function jump(){

        // 	let high = 8
        // 	for (let i = 0; i < high; i++){
        // 		doSetTimout(i)
        // 	}
        // 	setTimeout(move(), high*delay)
        // 	// for (let i = 0; i < high; i++){
        // 	// 	doSetTimout(high-i)
        // 	// }
        // 	press = false;
        // 	console.log("false")
        // }

        function loop() {
          cube.rotation.y += 0.01;

          //controls.update();
          renderer.render(scene, camera);
          // let distance = 0.30
          var delta = clock.getDelta(); // seconds.
          var moveDistance = 500 * delta; // 200 pixels per second
          //var rotateAngle = Math.PI / 2 * delta;   // pi/2 radians (90 degrees) per second

          if (keyboard.pressed("W")) controls.moveForward(distance);
          if (keyboard.pressed("D")) controls.moveRight(distance);
          if (keyboard.pressed("S")) controls.moveForward(-distance);
          if (keyboard.pressed("A")) controls.moveRight(-distance);
          // let press = false;
          if (keyboard.pressed("ctrl") && !press) {
            camera.position.y = 8;
          } else if (keyboard.pressed("space") && !press) {
            camera.position.y = 23;
            // press = true;
            // setTimeout(jump, 1000)
          } else if (!press) {
            camera.position.y = 15;
          }

          // console.log("AAAAAAAAAAA")

          requestAnimationFrame(loop);
        }

        loop();

        document.body.onresize = function () {
          var width = window.innerWidth;
          var height = window.innerHeight;

          renderer.setSize(width, height);
          camera.aspect = width / height;
          camera.updateProjectionMatrix();
        };
        document.body.onresize();
      };
    </script>
  </body>
</html>
